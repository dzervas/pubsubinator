use core::pin::Pin;

use alloc::boxed::Box;
use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;
use embassy_sync::pubsub::Subscriber;
use futures::Future;
use nrf_softdevice::ble::gatt_server::characteristic::Attribute;
use nrf_softdevice::ble::{gatt_server, peripheral};
use nrf_softdevice::{raw, Softdevice};
use usbd_hid::descriptor::KeyboardReport;

use defmt::*;

use crate::reactor::Consumer;
use crate::reactor_event::*;
use crate::{PUBSUB_CAPACITY, PUBSUB_SUBSCRIBERS, PUBSUB_PUBLISHERS};

#[nrf_softdevice::gatt_service(uuid = "180f")]
pub struct BatteryService {
	#[characteristic(uuid = "2a19", read, notify)]
	battery_level: u8,
}

// pub struct KeyboardReport {
// 	pub modifier: u8,
// 	pub reserved: u8,
// 	pub leds: u8,
// 	pub keycodes: [u8; 6],
// }

#[nrf_softdevice::gatt_service(uuid = "1812")]
pub struct KeyboardService {
	#[characteristic(uuid = "2a4a", read)]
	hid_information: [u8; 4], // Typically, the HID Information is 4 bytes, but it can vary.

	// #[characteristic(uuid = "2a4b", read, write)]
	// hid_control_point: u8, // HID Control Point, used for control commands like "suspend" or "exit suspend".

	// Boot Keyboard Input Report
	#[characteristic(uuid = "2a22", read, notify)]
	boot_keyboard_input_report: [u8; 8], // This size can vary based on your needs.

	// Boot Keyboard Output Report (LED states like Caps Lock)
	// #[characteristic(uuid = "2a32", write, notify)]
	// boot_keyboard_output_report: u8,

	// HID Report Map (describes the format of the HID reports)
	#[characteristic(uuid = "2a4b", read, write, notify, indicate, write_without_response)]
	report: [u8; 8], // This will be an array that describes the report format.

	// Other characteristics like HID Report can be added as needed.
}

// pub struct HidReportAttribute<T: AsRef<[u8]>>(Attribute<T>);

// impl<T: AsRef<[u8]>> HidReportAttribute<T> {
// 	pub fn new(value: T) -> Self {
// 		Self(Attribute::new(value))
// 	}

// 	pub fn deferred_read(&self) -> Attribute<T> {
// 		info!("deferred_read");
// 		self.0.deferred_read()
// 	}

// 	pub fn read_security(self, security: nrf_softdevice::ble::gatt_server::characteristic::Security) -> Self {
// 		info!("read_security");
// 		Self(self.0.read_security(security))
// 	}
// }

#[nrf_softdevice::gatt_server]
pub struct Server {
	bas: BatteryService,
	keyboard: KeyboardService,
}

pub struct BleHid<'a> {
	pub softdevice: &'a Softdevice,
	pub server: Server,
	pub report: KeyboardReport,
	pub channel: Subscriber<'a, CriticalSectionRawMutex, ReactorEvent, PUBSUB_CAPACITY, PUBSUB_SUBSCRIBERS, PUBSUB_PUBLISHERS>,
}

impl<'a> BleHid<'a> {
	pub async fn run(&mut self) {

		#[rustfmt::skip]
		let adv_data = &[
			0x02, 0x01, raw::BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE as u8,
			0x03, 0x03, 0x12, 0x18, // 3 bytes wide, HID service
			// 0x0a, 0x09, b"RustRover"[..],
			0x0a, 0x09, b'R', b'u', b's', b't', b'R', b'o', b'v', b'e', b'r',
		];
		#[rustfmt::skip]
		let scan_data = &[
			0x03, 0x03, 0x0f, 0x18, // 3 bytes wide, Battery service
		];

		self.server.keyboard.report_set(&[0x12, 0x34, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00]).unwrap();

		loop {
			let config = peripheral::Config::default();
			let adv = peripheral::ConnectableAdvertisement::ScannableUndirected { adv_data, scan_data };
			let conn = unwrap!(peripheral::advertise_connectable(self.softdevice, adv, &config).await);

			info!("advertising done!");

			// Run the GATT server on the connection. This returns when the connection gets disconnected.
			//
			// Event enums (ServerEvent's) are generated by nrf_softdevice::gatt_server
			// proc macro when applied to the Server struct above
			let e = gatt_server::run(&conn, &self.server, |e| match e {
				ServerEvent::Bas(e) => match e {
					BatteryServiceEvent::BatteryLevelCccdWrite { notifications } => {
						info!("battery notifications: {}", notifications)
					}
				},
				ServerEvent::Keyboard(e) => match e {
					KeyboardServiceEvent::ReportCccdWrite { notifications, indications } => {
						info!("keyboard notifications: {} {}", notifications, indications)
					},
					KeyboardServiceEvent::ReportWrite(report) => {
						info!("keyboard report: {:?}", report)
					},
					_ => info!("Unhandled keyboard event")
				},
				_ => info!("Unhandled event")
			})
			.await;

			info!("gatt_server run exited with error: {:?}", e);
		}
	}
}

impl<'a> Consumer for BleHid<'a> {
	fn push(&mut self, value: ReactorEvent) -> Pin<Box<dyn Future<Output = ()> + '_>> {
		Box::pin(async move {
			match value {
				ReactorEvent::Key(code) => {
					match code {
						KeyEvent::Pressed(key) => {
							info!("Pressed: {:?}", key);
							if key > KeyCode::LCtrl && key < KeyCode::RGui {
								self.report.modifier |= 1 << (key as u8 - KeyCode::LCtrl as u8);
							} else if !self.report.keycodes.contains(&(key as u8)) {
								if let Some(pos) = self.report.keycodes.iter().position(|&k| k == KeyCode::None as u8) {
									self.report.keycodes[pos] = key as u8;
								}
							}
						},
						KeyEvent::Released(key) => {
							info!("Released: {:?}", key);
							if key > KeyCode::LCtrl && key < KeyCode::RGui {
								self.report.modifier &= 0 << (key as u8 - KeyCode::LCtrl as u8);
							} else if let Some(pos) = self.report.keycodes.iter().position(|&k| k == key as u8) {
								self.report.keycodes[pos] = 0;
							}
						},
						// _ => {
						// 	info!("Unhandled event: {:?}", value);
						// },
					}
				},
				// ReactorEvent::Locks { caps, num, scroll } => {
				// 	self.report.modifier = 0;
				// 	self.report.keycodes[0] = caps as u8;
				// },
				// ReactorEvent::Mouse { x, y } => {
				// 	info!("Unhandled event: {:?}", value);
				// },
				_ => {
					info!("Unhandled event: {:?}", value);
					return;
				},
			}
		})
	}
}
